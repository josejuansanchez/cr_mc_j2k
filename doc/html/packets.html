<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <link rel="stylesheet" href="css/style.css" type="text/css" />
</head>
<body>
<h1 id="jpeg2000-packet-structure">JPEG2000 Packet Structure</h1>
<p>Ejemplo:</p>
<pre><code> FF 91    00 04    04 EC    C0 00 ...
\-----/  \-----/  \-----/  \--------/
 16 bits  16 bits  16 bits   N bits

 SOP       Lsop     Nsop     Packet Body</code></pre>
<p><strong>SOP</strong>: Start Of Packet marker.<br /><strong>Lsop</strong>: Length of marker segment in bytes (Not including the marker).<br /><strong>Nsop</strong>: Packet number (Possible values are between 0 and 65535).</p>
<h1 id="paquetes-vacíos">Paquetes vacíos</h1>
<p>Los paquetes vacíos que se han creado contienen 8 bytes y tienen el siguiente formato:</p>
<pre><code> FF 91   00 04   XX XX   80 00
\_____/ \_____/ \_____/ \_____/
  SOP    Lsop    Nsop    Packet Body</code></pre>
<ul>
<li><p><strong>SOP</strong>: Start of packet.</p></li>
<li><p><strong>Lsop</strong>: Length of marker segment in bytes (not including the marker).</p></li>
<li><p><strong>Nsop</strong>: Packet id [0..65535].</p></li>
<li><p><strong>Packet Body</strong>: Code-stream.</p></li>
<li><p><code>FF_{(16)} = unsigned char sop_0 = 255_{(10)}</code>.</p></li>
<li><p><code>91_{(16)} = unsigned char sop_1 = 145_{(10)}</code>.</p></li>
<li><p><code>00_{(16)} = unsigned char lsop_0 = 0_{(10)}</code>.</p></li>
<li><p><code>04_{(16)} = unsigned char lsop_1 = 4_{(10)}</code>.</p></li>
<li><p><code>XX XX</code> se corresponde con el id del paquete.</p></li>
<li><p><code>80_{(16)} = unsigned char body_0 = 128_{(10)}</code>.</p></li>
<li><p><code>00_{(16)} = unsigned char body_1 = 0_{(10)}</code>.</p></li>
</ul>
<h1 id="nuevo-tamaño-de-bloque-para-la-lectura-de-paquetes">Nuevo tamaño de bloque para la lectura de paquetes</h1>
<p>Se ha modificado el tamaño de la estructura que utilizábamos para leer los paquetes de los archivos <code>.j2c</code> para luego almacenarlos en nuestro formato interno <code>.j2c.cache</code>. Por ejemplo en la aplicación <code>woistocache</code> los paquetes se leían en bloques de <span class="math">500</span> bytes utilizando la estructura <code>kdu_byte data[500]</code>. De modo que para un paquete de <span class="math">2214</span> bytes tendríamos <span class="math">5</span> bloques en nuestro archivo <code>.j2c.cache</code>.</p>
<pre><code>precinct.id = 176: 7 2 0 5 6: 500 bytes
precinct.id = 176: 7 2 0 5 6: 500 bytes
precinct.id = 176: 7 2 0 5 6: 500 bytes
precinct.id = 176: 7 2 0 5 6: 500 bytes
precinct.id = 176: 7 2 0 5 6: 214 bytes</code></pre>
<p>Hemos aumentado el tamaño de bloque y ahora utilizamos la estructura <code>kdu_byte data[524288]</code>. De este modo garatizamos que en nuestro archivo <code>.j2c.cache</code> vamos a tener el paquete en un sólo bloque. (Tengo que revisar cuál es el tamaño máximo que puede tener un paquete)</p>
<h1 id="warning-parsing-sops">Warning!: Parsing SOPs</h1>
<p>Hemos detectado un posible error a la hora de obtener los paquetes de un code-stream JPEG2000 si lo hacemos buscando el marcador SOP.</p>
<ul>
<li><p><strong>SOP marker</strong><br />Si solamente buscamos el valor <code>0xFF91</code> del marcador podemos obtener una interpretación errónea de los paquetes.</p>
<p>Ejemplo:</p>
<pre><code>FF 91    00 04    00 FF    91 40 ...
\-----/  \-----/  \-----/  \--------/
16 bits  16 bits  16 bits   N bits

SOP       Lsop     Nsop     Packet Body</code></pre>
<p>En este caso el último byte de <strong>Nsop</strong> y el primer byte de <strong>Packet body</strong> forman el valor <code>0xFF91</code> y nos podría causar un error a la hora de obtener los paquetes de este code-stream.</p>
<p>En nuestros experimentos este caso era el que provocaba que nuestras utilidades &quot;countsops&quot; y &quot;woistocache&quot; obtuviesen un paquete de más.</p></li>
<li><p><strong>EOC marker</strong><br />Si solamente buscamos el valor <code>0xFFD9</code> del marcador podemos obtener una interpretación errónea de los paquetes.</p>
<p>Ejemplo:</p>
<pre><code> FF 91    00 04    01 FF    D9 ...
\-----/  \-----/  \-----/  \--------/
 16 bits  16 bits  16 bits   N bits

 SOP       Lsop     Nsop     Packet Body</code></pre>
<p>En nuestros experimentos este caso era el que provocaba que nuestras utilidades &quot;countsops&quot; y &quot;woistocache&quot; interpretasen que se había alcanzado el final del code-stream antes de tiempo.</p></li>
</ul>
<h1 id="cambios-en-la-utilidad-countsops">Cambios en la utilidad: <code>countsops</code></h1>
<p>Hemos modificado la utilidad y ahora para detectar que ha encontrado un paquete tiene que encontrar los siguientes 4 bytes seguidos.</p>
<pre><code> FF 91    00 04 
\-----/  \-----/
 16 bits  16 bits

 SOP       Lsop</code></pre>
<h1 id="cambios-en-la-librería-jp2_area.cpp">Cambios en la librería <code>jp2_area.cpp</code></h1>
<p>Hemos modificado el método <code>void jp2_area::get_packet_data(FILE *f, packet_data&amp; p)</code> de la librería <code>jp2_area.cpp</code> para evitar el problema de los marcadores <strong>SOP</strong>.</p>
<p>Ahora para garantizar que se ha encontrado un paquete tenemos que encontrar los siguientes 4 bytes seguidos.</p>
<pre><code> FF 91    00 04 
\-----/  \-----/
 16 bits  16 bits

 SOP       Lsop</code></pre>
<p>También nos hemos encontrado con un caso que podría dar lugar a confusión, porque se puede hacer una mala interpretación del marcador <strong>FF D9</strong> (End Of Code-stream).</p>
<pre><code> FF 91    00 04   01 FF    D9 ... ...
\-----/  \-----/ \-----/  \-----/
 16 bits 16 bits 16 bits

 SOP       Lsop   Nsop    Packet Body</code></pre>
<p>Para solucionarlo hemos comprobado que después del marcador <strong>FF D9</strong> no hay más bytes.</p>
</body>
</html>
